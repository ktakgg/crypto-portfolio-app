# 暗号資産ポートフォリオ管理アプリ プログラミング仕様書

**作成者**: Manus AI  
**作成日**: 2025年6月30日  
**バージョン**: 1.1  
**対象環境**: 静的ウェブページ

---

## 目次

1. [プロジェクト概要](#1-プロジェクト概要)
2. [機能要件](#2-機能要件)
3. [技術スタック](#3-技術スタック)
4. [システムアーキテクチャ](#4-システムアーキテクチャ)
5. [API設計](#5-api設計)
6. [フロントエンド設計](#6-フロントエンド設計)
7. [開発環境構築](#7-開発環境構築)
8. [実装ガイドライン](#8-実装ガイドライン)
9. [テスト戦略](#9-テスト戦略)
10. [デプロイメント](#10-デプロイメント)
11. [セキュリティ考慮事項](#11-セキュリティ考慮事項)
12. [パフォーマンス最適化](#12-パフォーマンス最適化)
13. [今後の拡張計画](#13-今後の拡張計画)
14. [参考資料](#14-参考資料)

---

## 1. プロジェクト概要

本プロジェクトは、EVM系（Ethereum Virtual Machine）およびSolana系ブロックチェーンに対応した暗号資産ポートフォリオ管理アプリケーションの開発を目的としている。ユーザーはログインを必要とせず、Cookieにより認識され、ウォレットアドレスもCookieに保存される。複数のウォレットアドレスを登録し、それぞれに任意の名前を付けて管理することができる。アプリケーションは各ウォレットのオンチェーンデータを自動的に取得し、シンプルで見やすいダッシュボードを通じて資産状況を可視化する。価格情報はAPIで取得するが、取得タイミングはページオープン時と30分間隔に限定し、外部APIへの負荷を軽減する。インターフェースは白ベースのミニマルデザインを採用し、ダッシュボードの各項目は表示・非表示設定とドラッグアンドドロップによる位置変更を可能とする。

### 1.1 プロジェクトの背景

暗号資産の普及に伴い、多くのユーザーが複数のブロックチェーンネットワークにわたって資産を保有するようになっている。しかし、各ブロックチェーンのネイティブウォレットやエクスプローラーは個別に確認する必要があり、全体的なポートフォリオの把握が困難である。特に、EVM系とSolana系という異なるアーキテクチャを持つブロックチェーン間での資産管理は、技術的な知識を要求される場合が多い。

本アプリケーションは、これらの課題を解決するために、統一されたインターフェースを通じて複数のブロックチェーンにわたる資産を一元管理できるソリューションを提供する。静的ウェブページとして実装することで、デプロイと運用を簡素化し、Google CLIでの開発とGit Pagesでのデプロイを前提とすることで、迅速な公開とメンテナンスを可能にする。

### 1.2 対象ユーザー

- 複数のブロックチェーンネットワークで暗号資産を保有する個人投資家
- DeFi（分散型金融）プロトコルを利用するユーザー
- NFT（非代替性トークン）コレクター
- 暗号資産の取引や投資を行う初心者から上級者まで

### 1.3 主要な価値提案

- **統一されたビュー**: EVM系とSolana系の資産を単一のダッシュボードで管理
- **リアルタイムデータ**: 最新の価格情報と残高を自動更新（30分間隔）
- **直感的なUI**: 技術的な知識がなくても使いやすいミニマルなインターフェース
- **カスタマイズ可能**: ウォレットに任意の名前を付けて整理、ダッシュボード項目の表示・非表示、ドラッグアンドドロップによる位置変更
- **包括的な情報**: トークン、NFT、取引履歴を網羅的に表示
- **手軽な利用**: ログイン不要でCookieによりユーザーを認識、ウォレットアドレスもCookieに保存




## 2. 機能要件

本セクションでは、暗号資産ポートフォリオ管理アプリケーションが提供すべき機能について詳細に説明する。機能要件は、ユーザーの視点から見た必要な機能と、システムが満たすべき技術的要件に分類される。

### 2.1 ユーザー認証とデータ永続化

#### 2.1.1 ログイン不要のユーザー認識

本アプリケーションは、ユーザーログイン機能を実装せず、Cookieを用いてユーザーを識別する。初回アクセス時に一意のユーザーIDを生成し、これをCookieに保存することで、ユーザーがブラウザを閉じたり、後日再アクセスしたりした場合でも、同一ユーザーとして認識し、保存されたウォレット情報や設定を復元できるようにする。ユーザーIDは匿名であり、個人を特定できる情報は含まない。

#### 2.1.2 ウォレットアドレスと設定のCookie保存

ユーザーが登録したウォレットアドレス、エイリアス、ダッシュボードの表示設定（表示・非表示、項目の順序など）は、ユーザーのブラウザのCookieに保存される。これにより、サーバーサイドのデータベースを不要とし、アプリケーションを完全に静的なウェブページとして運用することを可能にする。Cookieに保存されるデータは暗号化され、セキュリティを確保する。Cookieの有効期限は長期間（例：1年間）に設定し、ユーザーが頻繁に再設定を行う手間を省く。

### 2.2 ウォレット管理機能

#### 2.2.1 ウォレットアドレスの登録

ユーザーは、EVM系およびSolana系のウォレットアドレスを自由に登録することができる。登録時には、ウォレットアドレスの形式検証が行われ、無効なアドレスの登録を防ぐ。EVM系アドレスは42文字の16進数文字列（0xで始まる）、Solana系アドレスは32-44文字のBase58エンコードされた文字列として検証される。

登録プロセスでは、ユーザーがウォレットアドレスを入力フィールドに貼り付けまたは手動入力し、対応するブロックチェーンネットワークを選択する。システムは入力されたアドレスの形式を自動的に判定し、適切なネットワークを推奨する機能も提供する。重複するアドレスの登録は防止され、既に登録済みのアドレスを再度登録しようとした場合は適切なエラーメッセージが表示される。

#### 2.2.2 ウォレットエイリアスの設定

各登録されたウォレットアドレスには、ユーザーが任意の名前（エイリアス）を設定できる。これにより、「メインウォレット」「DeFi用」「NFT保管用」などの分かりやすい名前でウォレットを識別することが可能になる。エイリアスは最大50文字まで設定でき、絵文字の使用も可能である。

エイリアスの設定は登録時に行うことができ、後から編集することも可能である。同一ユーザー内でのエイリアスの重複は許可されるが、ユーザビリティの観点から重複時には警告メッセージを表示する。エイリアスが設定されていない場合は、ウォレットアドレスの短縮形（最初の6文字と最後の4文字を表示）がデフォルトの表示名として使用される。

#### 2.2.3 ウォレット情報の編集・削除

登録済みのウォレット情報は、いつでも編集または削除することができる。編集可能な項目は、エイリアス名とメモ（オプション）である。ウォレットアドレス自体は、データの整合性を保つため編集不可とし、変更が必要な場合は削除後に再登録する仕様とする。

削除機能では、誤操作を防ぐため確認ダイアログを表示し、削除実行前にユーザーの意図を再確認する。削除されたウォレットに関連するデータはCookieから削除される。

### 2.3 オンチェーンデータ取得機能

#### 2.3.1 ネイティブトークン残高の取得

各ウォレットアドレスについて、対応するブロックチェーンのネイティブトークン（ETH、SOLなど）の残高を取得する。残高データは、ブロックチェーンAPIから最新の情報を取得し、適切な単位（Wei、Lamportなど）から表示用の単位（ETH、SOLなど）に変換して表示する。

残高の取得は、ユーザーがダッシュボードにアクセスした際の自動更新、手動更新ボタンのクリック、および30分間隔での自動更新の3つのタイミングで実行される。取得したデータは、表示の高速化とAPIコールの削減のため、適切な期間（例：5分間）キャッシュされる。

#### 2.3.2 トークン残高と情報の取得

ERC-20トークン（EVM系）およびSPLトークン（Solana系）の残高と詳細情報を取得する。特に、Moralisの`getERC20TokenBalancesWithPricesByWallet`エンドポイントは、単一のAPIコールでウォレット内のERC20トークンの残高、価格、24時間変動率、ロゴ、名前など、ポートフォリオアプリに必要なあらゆる情報を提供する点で非常に効率的である。これにより、他のプロバイダーと比較してAPIコールの数を劇的に削減できる。取得する情報には、トークンシンボル、名前、デシマル数、コントラクトアドレス、現在価格、24時間変動率、ロゴ画像URLが含まれる。

トークン情報の取得では、まずウォレットアドレスが保有するトークンのリストを取得し、各トークンについて詳細情報を並行して取得する。大量のトークンを保有するウォレットの場合、パフォーマンスを考慮してページネーションやバッチ処理を実装する。価格情報については、主要な価格フィードAPI（CoinGecko、CoinMarketCapなど）と連携し、リアルタイムの市場価格を提供する。価格情報の更新は、ページオープン時と30分間隔で行われる。

#### 2.3.3 NFT情報の取得

ウォレットが保有するNFT（ERC-721、ERC-1155、Solana NFTなど）の情報を取得し、表示する。取得する情報には、NFTの名前、説明、画像URL、メタデータURI、コレクション情報、属性（traits）、推定価値（利用可能な場合）が含まれる。

NFTデータの取得では、まずウォレットが保有するNFTのトークンIDとコントラクトアドレスのリストを取得し、各NFTのメタデータを並行して取得する。メタデータの取得には、IPFS、Arweave、HTTPSなど様々なプロトコルに対応する必要がある。画像の表示では、遅延読み込み（lazy loading）を実装し、ユーザーエクスペリエンスを向上させる。

#### 2.3.4 取引履歴の取得

各ウォレットアドレスの取引履歴を取得し、時系列で表示する機能を提供する。取得する情報には、取引ハッシュ、送信者・受信者アドレス、取引金額、ガス使用量、ガス価格、ブロック番号、タイムスタンプ、取引タイプ（送金、スワップ、NFT取引など）が含まれる。

取引履歴の取得では、パフォーマンスを考慮して最新の100件から開始し、ユーザーの要求に応じて追加の履歴を読み込む無限スクロール機能を実装する。取引の分類（入金、出金、スワップ、DeFi操作など）を自動的に判定し、ユーザーが理解しやすい形で表示する。

### 2.4 ポートフォリオ可視化機能

#### 2.4.1 総資産価値の表示

登録された全ウォレットの合計資産価値をUSD換算で表示する。計算には、各トークンの現在価格と保有数量を乗算し、全てのトークンの価値を合計する。NFTについては、フロア価格や最近の取引価格を基に推定価値を算出する（データが利用可能な場合）。

総資産価値は、ダッシュボードの最上部に大きく表示され、24時間変動率と変動金額も併せて表示する。変動率は色分け（上昇：緑、下降：赤、変動なし：グレー）で視覚的に分かりやすく表現する。また、週次、月次、年次の変動率も表示し、長期的なトレンドを把握できるようにする。

#### 2.4.2 資産分布の可視化

ポートフォリオの構成を様々な観点から可視化する。主要な可視化方法には、チェーン別分布（Ethereum、Solana、その他）、トークン別分布（上位10トークン）、資産タイプ別分布（ネイティブトークン、ERC-20/SPLトークン、NFT）がある。

可視化には、円グラフ、ドーナツチャート、横棒グラフなどを使用し、ユーザーが直感的に理解できる形で表示する。各セクションはインタラクティブで、クリックすることで詳細情報を表示したり、該当する資産のリストにジャンプしたりできる。小さな割合の資産は「その他」としてまとめ、必要に応じて展開表示する機能も提供する。

#### 2.4.3 価格推移とパフォーマンス分析

個別トークンおよびポートフォリオ全体の価格推移をグラフで表示する。時間軸は、1時間、24時間、7日間、30日間、90日間、1年間から選択可能とし、ユーザーが関心のある期間でのパフォーマンスを確認できる。

グラフには、価格の絶対値だけでなく、パーセンテージ変動も表示し、投資パフォーマンスを評価しやすくする。主要な市場イベント（大きな価格変動、重要なニュースなど）をグラフ上にアノテーションとして表示する機能も検討する。また、ベンチマーク（Bitcoin、Ethereum、S&P 500など）との比較機能も提供し、相対的なパフォーマンスを評価できるようにする。

### 2.5 ユーザーインターフェース要件

#### 2.5.1 レスポンシブデザイン

アプリケーションは、デスクトップ、タブレット、モバイルデバイスで最適な表示を実現するレスポンシブデザインを採用する。ブレークポイントは、モバイル（768px未満）、タブレット（768px-1024px）、デスクトップ（1024px以上）の3段階とし、各デバイスサイズに適したレイアウトを提供する。

モバイルデバイスでは、サイドバーをハンバーガーメニューに変更し、テーブル表示をカード形式に変更するなど、タッチ操作に適したインターフェースを提供する。フォントサイズ、ボタンサイズ、タップターゲットサイズも、各デバイスでの使いやすさを考慮して調整する。

#### 2.5.2 ミニマルデザインと白ベースのインターフェース

インターフェースは、白を基調としたミニマルデザインを採用する。これにより、情報の視認性を高め、ユーザーが主要なデータに集中できる環境を提供する。余分な装飾を排し、シンプルでクリーンなレイアウトを心がける。主要な要素には、控えめなシャドウやボーダーを使用し、視覚的な階層を明確にする。

#### 2.5.3 ダッシュボード項目の表示・非表示設定

ユーザーは、ダッシュボードに表示される各項目（例：総資産価値、資産分布、個別トークンリスト、NFTギャラリーなど）を個別に表示・非表示設定できる機能を提供する。設定はCookieに保存され、次回アクセス時にも反映される。これにより、ユーザーは自分にとって最も重要な情報のみを表示し、パーソナライズされたダッシュボードを構築できる。

#### 2.5.4 ダッシュボード項目のドラッグアンドドロップによる位置変更

ダッシュボードの各項目は、ドラッグアンドドロップ操作により自由に位置を変更できる機能を提供する。これにより、ユーザーは情報の優先順位に応じてレイアウトをカスタマイズできる。位置変更の設定もCookieに保存され、次回アクセス時にも反映される。直感的でスムーズなドラッグアンドドロップ体験を提供するため、適切なライブラリ（例：React Beautiful DnD）の導入を検討する。

#### 2.5.5 アクセシビリティ

アプリケーションは、障害を持つユーザーも含めて誰もが利用できるよう、アクセシビリティに配慮した設計とする。具体的には、セマンティックHTMLの使用、適切なaria-label属性の設定、キーボードナビゲーション対応、スクリーンリーダー対応を実装する。

色のみに依存した情報伝達を避け、アイコンやテキストラベルも併用する。フォーカス表示を明確にし、タブキーでの操作順序を論理的に設定する。また、動的コンテンツの変更をスクリーンリーダーに適切に通知するため、live regionsを活用する。

### 2.6 パフォーマンス要件

#### 2.6.1 応答時間

ユーザーアクションに対する応答時間は、以下の基準を満たすものとする：

- ページの初期読み込み：3秒以内
- ウォレットデータの更新：5秒以内
- ユーザーインタラクション（ボタンクリック、フォーム送信など）：1秒以内
- チャートやグラフの描画：2秒以内

これらの基準を満たすため、データのキャッシュ、遅延読み込み、プリフェッチ、コード分割などの最適化技術を積極的に活用する。

#### 2.6.2 スケーラビリティ

アプリケーションは、ユーザー数の増加やデータ量の増大に対応できるスケーラブルな設計とする。データベースを使用しないため、サーバーサイドのスケーラビリティは考慮不要だが、フロントエンドのパフォーマンス最適化、APIレスポンスのページネーション、CDNの活用などを通じて、パフォーマンスの維持を図る。

また、ブロックチェーンAPIの利用制限に対応するため、複数のAPIプロバイダーの併用、レート制限の管理、フォールバック機能の実装を行う。




## 3. 技術スタック

本セクションでは、暗号資産ポートフォリオ管理アプリケーションの開発に使用する技術スタックについて詳細に説明する。技術選定は、静的ウェブページとしての特性、機能要件、拡張性、保守性を総合的に考慮して行われている。

### 3.1 フロントエンド技術

#### 3.1.1 React

フロントエンドフレームワークとしてReactを採用する。Reactは、コンポーネントベースのアーキテクチャにより、再利用可能なUIコンポーネントの開発を可能にし、大規模なアプリケーションの開発と保守を効率化する。また、豊富なエコシステムと活発なコミュニティサポートにより、必要なライブラリやツールが充実している。

Reactの仮想DOM（Virtual DOM）機能により、効率的なDOM操作が実現され、ユーザーインターフェースのパフォーマンスが向上する。特に、リアルタイムで更新される価格情報や残高データの表示において、この特性は重要な利点となる。また、React Hooksを活用することで、関数コンポーネントでの状態管理とライフサイクル管理が簡潔に記述できる。

#### 3.1.2 TypeScript

JavaScriptの代わりにTypeScriptを使用することで、型安全な開発を実現する。TypeScriptの静的型チェック機能により、開発時にエラーを早期発見でき、コードの品質と保守性が向上する。特に、ブロックチェーンAPIからのレスポンスデータや複雑なデータ構造を扱う際に、型定義による恩恵は大きい。

TypeScriptの型システムは、APIレスポンスの型定義、コンポーネントのProps型定義、状態管理の型安全性確保に活用される。また、IDEの支援機能（自動補完、リファクタリング、エラー検出など）が充実し、開発効率が大幅に向上する。

#### 3.1.3 状態管理

アプリケーションの状態管理には、React Context APIとuseReducerフックの組み合わせ、または必要に応じてRedux Toolkitを使用する。小規模から中規模のアプリケーションでは、React Context APIで十分な機能を提供できるが、状態の複雑さが増した場合にはRedux Toolkitへの移行を検討する。

主要な状態には、ユーザーが登録したウォレット情報、取得したポートフォリオデータ、アプリケーションの設定（テーマ、言語など）、ローディング状態、エラー状態が含まれる。状態の更新は、イミュータブルな方式で行い、予期しない副作用を防ぐ。

#### 3.1.4 ルーティング

シングルページアプリケーション（SPA）のルーティングには、React Routerを使用する。主要なルートには、ダッシュボード（/dashboard）、ウォレット詳細（/wallet/:id）、ウォレット管理（/wallets）、設定（/settings）が含まれる。

ルーティングでは、動的インポート（Dynamic Import）を活用したコード分割を実装し、初期読み込み時間を短縮する。また、ブラウザの戻る・進むボタンに対応し、ユーザーが期待する通りのナビゲーション体験を提供する。

#### 3.1.5 UIライブラリとスタイリング

UIコンポーネントライブラリとして、Tailwind CSSを採用する。Tailwind CSSは、ユーティリティファーストのアプローチにより、カスタムデザインの実装が容易で、一貫性のあるスタイリングを実現できる。また、PurgeCSS機能により、使用されていないCSSを自動的に削除し、バンドルサイズを最適化する。

チャートとグラフの描画には、Chart.jsまたはRechartsライブラリを使用する。これらのライブラリは、レスポンシブデザインに対応し、インタラクティブなチャートを簡単に実装できる。アニメーション効果には、Framer Motionライブラリを使用し、滑らかで魅力的なユーザーインターフェースを実現する。

### 3.2 開発ツールと環境

#### 3.2.1 Google CLI

開発プラットフォームとしてGoogle CLIを想定する。Google CLIは、Google Cloud Platformのサービスをコマンドラインから操作するためのツールであり、開発環境のセットアップ、デプロイ、管理を効率的に行うことができる。特に、Google Cloud StorageやCloud Functionsなど、必要に応じてGoogle Cloudのサービスと連携する際に活用する。

#### 3.2.2 パッケージ管理

Node.jsプロジェクトのパッケージ管理には、npmまたはyarnを使用する。package.jsonファイルで依存関係を管理し、セマンティックバージョニングに従ってライブラリのバージョンを指定する。開発依存関係と本番依存関係を適切に分離し、本番環境でのバンドルサイズを最適化する。

セキュリティの観点から、定期的に依存関係の脆弱性チェックを実行し、必要に応じてライブラリのアップデートを行う。npm auditコマンドやSnykなどのツールを活用し、セキュリティリスクを最小限に抑える。

#### 3.2.3 バージョン管理

ソースコードのバージョン管理には、Gitを使用する。GitHubなどのリモートリポジトリとの連携が可能である。ブランチ戦略として、Git Flowまたは GitHub Flowを採用し、機能開発、バグ修正、リリースを体系的に管理する。

コミットメッセージは、Conventional Commitsの規約に従い、変更内容を明確に記述する。また、プルリクエストベースの開発フローを採用し、コードレビューを通じて品質を確保する。

### 3.3 外部サービスとAPI

#### 3.3.1 ブロックチェーンデータプロバイダー

**Moralis**は、Web3開発に特化したバックエンドサービスであり、EVM系とSolana系の両方に対応している。リアルタイムデータ、NFTメタデータ、DeFiプロトコルデータなど、包括的なブロックチェーンデータを提供する。また、WebSocketを通じたリアルタイム更新機能も利用できる。

**QuickNode**は、高性能なブロックチェーンインフラストラクチャを提供し、低レイテンシでのデータアクセスが可能である。Core API、Token API、NFT APIなど、用途別に最適化されたAPIエンドポイントを提供する。また、カスタムRPCエンドポイントの作成も可能である。

**Alchemy**は、開発者向けのブロックチェーンプラットフォームであり、Enhanced APIを通じて高度な機能を提供する。Webhook機能により、特定のイベント（トランザクション、残高変更など）をリアルタイムで通知できる。

これらのAPIは、フロントエンドから直接呼び出すことを想定する。API統合では、レート制限の管理、エラーハンドリング、フォールバック機能を実装する。複数のAPIプロバイダーを併用することで、単一障害点を避け、サービスの可用性を向上させる。また、APIレスポンスのキャッシュ機能により、同一データへの重複リクエストを削減し、パフォーマンスを向上させる。

#### 3.3.2 価格データプロバイダー

トークンの価格データには、CoinGecko APIまたはCoinMarketCap APIを使用する。これらのAPIは、数千種類の暗号資産の価格、市場データ、履歴データを提供する。レート制限内での効率的な利用のため、価格データのキャッシュとバッチ取得を実装する。価格情報の更新は、ページオープン時と30分間隔で行われる。

#### 3.3.3 画像とメディア処理

NFTの画像表示には、IPFSゲートウェイ（Pinata、Infura、CloudFlareなど）を使用する。画像の読み込み速度向上のため、CDN（Content Delivery Network）を活用し、適切なキャッシュヘッダーを設定する。また、画像の遅延読み込みとプレースホルダー表示により、ユーザーエクスペリエンスを向上させる。

### 3.4 セキュリティとプライバシー

#### 3.4.1 データ保護

ユーザーのウォレットアドレスは、パブリックな情報であるが、プライバシー保護の観点から適切に管理する。Cookieに保存されるデータは、必要最小限の情報のみとし、個人を特定できる情報は避ける。また、データの暗号化とアクセス制御により、不正アクセスを防ぐ。

#### 3.4.2 API セキュリティ

フロントエンドから直接APIを呼び出すため、APIキーの管理には注意が必要である。公開可能なAPIキーを使用するか、プロキシサーバーを介してAPIキーを秘匿するなどの対策を検討する。CORS（Cross-Origin Resource Sharing）の適切な設定、レート制限の実装により、セキュリティを確保する。

#### 3.4.3 入力検証

ユーザーからの入力データは、すべてクライアントサイドで検証し、不正なデータ入力を防ぐ。バリデーションライブラリを使用し、一貫性のある検証ロジックを実装する。




## 4. システムアーキテクチャ

本セクションでは、暗号資産ポートフォリオ管理アプリケーションの全体的なシステムアーキテクチャについて詳細に説明する。アーキテクチャ設計は、静的ウェブページとしての特性、スケーラビリティ、保守性、パフォーマンス、セキュリティを重視して行われている。

### 4.1 全体アーキテクチャ概要

アプリケーションは、完全にクライアントサイドで動作する静的ウェブページとして構成される。ユーザーのブラウザが主要な処理（ウォレット管理、データ取得、UI表示）を担い、外部のブロックチェーンAPIや価格データAPIと直接通信する。サーバーサイドのコンポーネントは存在せず、デプロイされた静的ファイルがウェブサーバー（Git Pagesなど）から配信される。

```
┌─────────────────┐    ┌─────────────────┐
│   User Browser  │    │   Static Files  │
│   (React/TS)    │◄──►│   (HTML, CSS, JS) │
│                 │    │                 │
└─────────────────┘    └─────────────────┘
         │                     ▲
         │                     │
         ▼                     │
┌─────────────────┐    ┌─────────────────┐
│ Blockchain APIs │    │  Web Server     │
│ (Moralis/       │    │  (Git Pages)    │
│ QuickNode/      │    │                 │
│ Alchemy)        │    └─────────────────┘
└─────────────────┘
         │
         ▼
┌─────────────────┐
│ Price Data APIs │
│ (CoinGecko/     │
│ CoinMarketCap)  │
└─────────────────┘
```

### 4.2 フロントエンドアーキテクチャ

#### 4.2.1 コンポーネント階層

フロントエンドは、Reactのコンポーネントベースアーキテクチャに従い、再利用可能なコンポーネントの階層構造で設計される。最上位のAppコンポーネントから始まり、ページレベル、セクションレベル、UIコンポーネントレベルの階層に分かれる。

```
App
├── Layout
│   ├── Header
│   │   ├── Logo
│   │   ├── Navigation
│   │   └── ThemeToggle
│   ├── Sidebar
│   │   ├── WalletList
│   │   └── AddWalletButton
│   └── Footer
├── Pages
│   ├── Dashboard
│   │   ├── PortfolioSummary
│   │   ├── WalletCards
│   │   ├── TokenTable
│   │   └── NFTGrid
│   ├── WalletDetail
│   │   ├── WalletHeader
│   │   ├── AssetSummary
│   │   ├── TokenDetails
│   │   └── NFTDetails
│   └── WalletManagement
│       ├── AddWalletForm
│       └── WalletList
└── Common
    ├── Button
    ├── Input
    ├── Modal
    ├── Chart
    └── LoadingSpinner
```

#### 4.2.2 状態管理アーキテクチャ

アプリケーションの状態は、グローバル状態とローカル状態に分類される。グローバル状態は、React Context APIまたはRedux Toolkitで管理し、複数のコンポーネント間で共有される。ローカル状態は、useStateフックで管理し、単一コンポーネント内でのみ使用される。

グローバル状態の構造：
```typescript
interface AppState {
  user: {
    preferences: UserPreferences;
    theme: 'light' | 'dark';
    dashboardLayout: DashboardLayoutItem[]; // 新規追加：ダッシュボードレイアウト情報
  };
  wallets: {
    list: Wallet[];
    loading: boolean;
    error: string | null;
  };
  portfolio: {
    data: PortfolioData;
    lastUpdated: Date;
    loading: boolean;
  };
  ui: {
    sidebarOpen: boolean;
    activeModal: string | null;
  };
}

interface DashboardLayoutItem {
  id: string; // 項目の識別子 (例: 'portfolioSummary', 'tokenList')
  isVisible: boolean; // 表示・非表示設定
  order: number; // 表示順序
}
```

#### 4.2.3 ルーティングアーキテクチャ

React Routerを使用したクライアントサイドルーティングにより、シングルページアプリケーション（SPA）として動作する。主要なルートは以下の通りである：

- `/` - ダッシュボード（デフォルト）
- `/dashboard` - ポートフォリオダッシュボード
- `/wallet/:id` - 特定ウォレットの詳細表示
- `/wallets` - ウォレット管理画面
- `/settings` - アプリケーション設定
- `/about` - アプリケーション情報

各ルートは、動的インポートを使用してコード分割され、初期読み込み時間の短縮を図る。また、ルートガード機能により、必要な条件（ウォレット登録済みなど）を満たさない場合の適切なリダイレクトを実装する。

### 4.3 データ永続化アーキテクチャ

本アプリケーションでは、サーバーサイドのデータベースを使用せず、ユーザーのブラウザのCookieにデータを永続化する。これにより、アプリケーションのデプロイと運用が大幅に簡素化される。

```
┌─────────────────┐
│   User Browser  │
│   (React/TS)    │
│                 │
│  ┌────────────┐ │
│  │   Cookie   │ │
│  │ (User ID,  │ │
│  │ Wallets,   │ │
│  │ Settings)  │ │
│  └────────────┘ │
└─────────────────┘
```

Cookieに保存されるデータは、JSON形式でシリアライズされ、必要に応じて暗号化される。Cookieのサイズ制限（通常4KB程度）を考慮し、大量のデータを保存しないように設計する。ウォレットアドレスや設定情報など、比較的少量のデータに適している。

### 4.4 外部API連携アーキテクチャ

アプリケーションは、ブロックチェーンデータプロバイダー（Moralis, QuickNode, Alchemyなど）および価格データプロバイダー（CoinGecko, CoinMarketCapなど）のAPIと直接連携する。これらのAPIは、フロントエンドからHTTPリクエストを送信することで利用される。

API呼び出しは、ページオープン時と30分間隔で実行される。これにより、外部APIへの負荷を軽減しつつ、最新のデータを提供できる。APIキーの管理には、環境変数やプロキシサーバーの利用を検討し、セキュリティを確保する。




## 5. API設計

本セクションでは、暗号資産ポートフォリオ管理アプリケーションが利用する外部APIとの連携について詳細に説明する。本アプリケーションは静的ウェブページとして動作するため、サーバーサイドAPIは存在せず、フロントエンドから直接ブロックチェーンデータプロバイダーおよび価格データプロバイダーのAPIを呼び出す。

### 5.1 外部API連携の原則

- **直接呼び出し**: フロントエンド（ユーザーのブラウザ）から直接外部APIを呼び出す。
- **非同期処理**: すべてのAPI呼び出しは非同期で行い、UIのブロックを防ぐ。
- **エラーハンドリング**: API呼び出しの失敗（ネットワークエラー、レート制限、不正なレスポンスなど）に対して適切なエラーハンドリングを実装し、ユーザーに分かりやすいメッセージを表示する。
- **レート制限の考慮**: 各APIプロバイダーのレート制限を遵守し、過度なリクエストを避けるためのメカニズム（例：リクエストキュー、指数関数的バックオフ）を実装する。
- **データキャッシュ**: 頻繁にアクセスされるデータや、更新頻度が低いデータはクライアントサイドでキャッシュし、API呼び出し回数を削減する。

### 5.2 ブロックチェーンデータAPI

ウォレットの残高、トークン情報、NFTデータ、取引履歴の取得には、Moralis, QuickNode, AlchemyなどのブロックチェーンデータプロバイダーのAPIを利用する。これらのAPIは、EVM系およびSolana系の両方のチェーンに対応している。

#### 5.2.1 主要なAPIエンドポイント（例）

- **ウォレットのネイティブトークン残高取得**: `/wallets/{address}/balance` (例: Moralis `getNativeBalance`)
- **ウォレットのトークン残高取得**: `/wallets/{address}/tokens` (例: Moralis `getERC20TokenBalancesWithPricesByWallet` - 単一APIコールでトークン残高、価格、24時間変動率、ロゴ、名前などを取得可能)
- **ウォレットのNFT情報取得**: `/wallets/{address}/nfts` (例: Moralis `getWalletNFTs`)
- **ウォレットの取引履歴取得**: `/wallets/{address}/transactions` (例: Moralis `getWalletTransactions`)

#### 5.2.2 API呼び出しのタイミング

ブロックチェーンデータAPIの呼び出しは、以下のタイミングで実行される。

1.  **ページオープン時**: アプリケーションがロードされた際、Cookieに保存されているウォレットアドレスのデータを自動的に取得し、ダッシュボードに表示する。
2.  **手動更新**: ユーザーがダッシュボード上の更新ボタンをクリックした際、最新のデータを取得する。
3.  **自動更新**: ページオープン後、30分間隔で自動的にウォレットデータを更新する。これにより、常に最新に近い情報を提供しつつ、APIへの負荷を軽減する。

### 5.3 価格データAPI

トークンの現在価格、24時間変動率などの市場データ取得には、CoinGecko APIまたはCoinMarketCap APIを利用する。

#### 5.3.1 主要なAPIエンドポイント（例）

- **暗号資産の現在価格取得**: `/simple/price` (例: CoinGecko `simple/price`)
- **暗号資産の市場データ取得**: `/coins/{id}` (例: CoinGecko `coins/{id}`)

#### 5.3.2 API呼び出しのタイミング

価格データAPIの呼び出しは、以下のタイミングで実行される。

1.  **ページオープン時**: アプリケーションがロードされた際、表示に必要なトークンの価格データを取得する。
2.  **自動更新**: ページオープン後、30分間隔で自動的に価格データを更新する。これにより、外部APIへの負荷を軽減し、効率的なデータ取得を行う。

### 5.4 APIキーの管理

外部APIを利用する際にはAPIキーが必要となる場合がある。静的ウェブページであるため、APIキーをクライアントサイドに直接埋め込むことはセキュリティリスクを伴う。以下のいずれかの方法でAPIキーを管理する。

- **公開可能なAPIキーの利用**: 一部のAPIは、公開しても問題ない（レート制限のみで認証不要な）キーを提供している場合がある。これらを活用する。
- **プロキシサーバーの利用**: 必要に応じて、APIキーを秘匿するためのシンプルなプロキシサーバー（例: Cloudflare Workers, Netlify Functionsなど）を構築し、フロントエンドからプロキシ経由でAPIを呼び出す。これにより、APIキーがクライアントサイドに露出するのを防ぐ。




## 6. フロントエンド設計

本セクションでは、暗号資産ポートフォリオ管理アプリケーションのフロントエンド設計について詳細に説明する。ユーザーインターフェース（UI）とユーザーエクスペリエンス（UX）は、シンプルさ、直感性、カスタマイズ性を重視して設計される。

### 6.1 デザイン原則

- **ミニマルデザイン**: 余分な要素を排除し、コンテンツと機能に焦点を当てる。クリーンで整理されたレイアウトにより、情報の視認性を最大化する。
- **白ベースのインターフェース**: メインカラーとして白を基調とし、清潔感と開放感のあるデザインを実現する。アクセントカラーは控えめに使用し、重要な情報やインタラクティブな要素を際立たせる。
- **直感的な操作**: ユーザーが迷うことなく目的の操作を行えるよう、一般的なUIパターンと明確な視覚的フィードバックを提供する。
- **カスタマイズ性**: ユーザーが自身のニーズに合わせてダッシュボードをパーソナライズできる機能を提供する。
- **レスポンシブ**: デスクトップ、タブレット、モバイルデバイスのいずれからアクセスしても、最適な表示と操作性を提供する。

### 6.2 主要画面とコンポーネント

#### 6.2.1 ダッシュボード

アプリケーションのメイン画面であり、登録されたウォレットの資産状況を一目で把握できる。以下の主要な項目で構成される。

- **総資産価値**: 全ウォレットの合計資産価値（USD換算）と24時間変動率。
- **資産分布**: チェーン別、トークン別、資産タイプ別の円グラフや棒グラフ。
- **ウォレットリスト**: 登録されたウォレットの一覧と、それぞれの主要な資産情報。
- **個別トークンリスト**: 保有するトークンの一覧、数量、現在価格、24時間変動率。
- **NFTギャラリー**: 保有するNFTのサムネイル表示。
- **取引履歴**: 最新の取引履歴。

#### 6.2.2 ウォレット管理画面

ウォレットの追加、編集、削除を行う画面。ウォレットアドレスの入力フォーム、エイリアス設定、登録済みウォレットの一覧表示と操作ボタンが配置される。

#### 6.2.3 ウォレット詳細画面

特定のウォレットの詳細な資産情報（ネイティブトークン、ERC-20/SPLトークン、NFT、取引履歴など）を表示する画面。

#### 6.2.4 設定画面

アプリケーションの全体設定を行う画面。テーマの切り替え（ライト/ダークモード）、言語設定、Cookieデータの管理など。

### 6.3 ダッシュボードのカスタマイズ機能

#### 6.3.1 項目の表示・非表示設定

ユーザーは、ダッシュボードに表示される各項目（例: 総資産価値、資産分布、個別トークンリスト、NFTギャラリー、取引履歴など）を個別に表示・非表示に設定できる機能を提供する。設定はUI上のチェックボックスやトグルスイッチを通じて行われ、即座にダッシュボードに反映される。この設定はCookieに保存され、ユーザーがブラウザを閉じても次回アクセス時に復元される。

#### 6.3.2 ドラッグアンドドロップによる位置変更

ダッシュボードの各項目は、ドラッグアンドドロップ操作により自由に位置を変更できる機能を提供する。これにより、ユーザーは自分にとって最も重要な情報を画面上部の目立つ位置に配置したり、関連する情報をまとめて表示したりするなど、レイアウトを柔軟にカスタマイズできる。ドラッグアンドドロップ操作は直感的でスムーズな体験を提供し、位置変更の設定もCookieに保存され、次回アクセス時に復元される。実装には、React Beautiful DnDなどのライブラリの活用を検討する。

### 6.4 スタイリングとUIコンポーネント

- **CSSフレームワーク**: Tailwind CSSを使用し、ユーティリティファーストのアプローチで高速なスタイリングを実現する。カスタムCSSは必要最小限に抑える。
- **アイコン**: シンプルで視認性の高いアイコンセット（例: Feather Icons, Material Design Icons）を使用する。
- **フォント**: 可読性の高いサンセリフフォント（例: Inter, Noto Sans JP）を選定する。
- **チャートライブラリ**: Chart.jsまたはRechartsを使用し、インタラクティブでレスポンシブなデータ可視化を実現する。
- **アニメーション**: Framer Motionなどのライブラリを使用し、スムーズなトランジションやマイクロインタラクションを実装し、ユーザーエクスペリエンスを向上させる。




## 7. 開発環境構築

本セクションでは、暗号資産ポートフォリオ管理アプリケーションの開発環境構築について説明する。本アプリケーションは静的ウェブページとして開発されるため、サーバーサイドの環境構築は不要である。Google CLIを開発プラットフォームとして想定し、フロントエンド開発に必要なツールを中心に構成する。

### 7.1 前提条件

- Node.js (LTSバージョン推奨)
- npm または Yarn
- Git
- Google Cloud SDK (Google CLIを含む)

### 7.2 開発環境のセットアップ

#### 7.2.1 Google Cloud SDKのインストール

Google Cloud SDKは、Google Cloud Platformのサービスをコマンドラインから操作するためのツールセットである。これにはGoogle CLIが含まれており、将来的にGoogle Cloud Storageなどと連携する際に役立つ。

1.  Google Cloud SDKの公式ドキュメントに従い、お使いのOSに合った方法でSDKをインストールする。
    [Google Cloud SDKのインストール](https://cloud.google.com/sdk/docs/install)
2.  インストール後、`gcloud init` コマンドを実行し、初期設定を行う。これにより、Google Cloudアカウントとの連携が確立される。

#### 7.2.2 プロジェクトのクローンと依存関係のインストール

1.  Gitリポジトリからプロジェクトをローカルにクローンする。
    ```bash
    git clone <your-repository-url>
    cd <your-project-directory>
    ```
2.  フロントエンドの依存関係をインストールする。
    ```bash
    npm install
    # または
    yarn install
    ```

#### 7.2.3 開発サーバーの起動

Reactアプリケーションを開発するために、ローカル開発サーバーを起動する。

```bash
npm start
# または
yarn start
```

通常、これによりブラウザが自動的に開き、`http://localhost:3000` でアプリケーションにアクセスできるようになる。コードの変更はリアルタイムでブラウザに反映される（ホットリロード）。

### 7.3 外部APIキーの設定

本アプリケーションは外部のブロックチェーンAPIや価格データAPIを利用するため、APIキーが必要となる場合がある。これらのAPIキーは、環境変数として管理し、ソースコードに直接記述しないようにする。

- 開発環境では、`.env` ファイルを使用してAPIキーを管理する。`.env` ファイルはGit管理から除外する（`.gitignore` に追加する）。
- ビルド時には、CI/CDパイプラインを通じて環境変数を注入するか、プロキシサーバーを利用してAPIキーを秘匿する。

例: `.env` ファイルの内容
```
REACT_APP_MORALIS_API_KEY=your_moralis_api_key
REACT_APP_COINGECKO_API_KEY=your_coingecko_api_key
```

### 7.4 推奨開発ツール

- **コードエディタ**: Visual Studio Code (VS Code) を推奨。TypeScript、React、Tailwind CSSの拡張機能が豊富に用意されている。
- **ブラウザ**: Google Chrome を推奨。開発者ツールが充実しており、デバッグやパフォーマンス分析に役立つ。
- **Gitクライアント**: コマンドラインGitまたはVS Codeに統合されたGit機能。




## 8. 実装ガイドライン

本セクションでは、暗号資産ポートフォリオ管理アプリケーションの実装における一般的なガイドラインとベストプラクティスについて説明する。これらのガイドラインは、コードの一貫性、保守性、パフォーマンス、およびセキュリティを確保することを目的としている。

### 8.1 コーディング規約

- **TypeScript**: TypeScriptの公式スタイルガイドまたは一般的なコミュニティのベストプラクティス（例: AirbnbスタイルガイドのTypeScript版）に従う。
- **React**: Reactの公式ドキュメントで推奨されるプラクティス（例: 関数コンポーネントとHooksの使用、コンポーネントの責務の分離）に従う。
- **命名規則**: 変数、関数、コンポーネント、ファイル名には、明確で意味のある名前を使用する。キャメルケース（camelCase）を推奨。
- **コメント**: 複雑なロジックや非自明な部分には、適切なコメントを記述する。JSDoc形式でのコメントを推奨。
- **コードフォーマット**: PrettierやESLintなどのツールを導入し、コードの自動フォーマットと静的解析を行う。これにより、コードの一貫性を保ち、潜在的な問題を早期に発見する。

### 8.2 コンポーネント設計

- **再利用性**: UIコンポーネントは、可能な限り再利用可能に設計する。汎用的なコンポーネント（ボタン、入力フィールド、モーダルなど）は、独立したファイルで定義し、他のコンポーネントからインポートして使用する。
- **責務の分離**: 各コンポーネントは単一の責務を持つように設計する。プレゼンテーションロジックとビジネスロジックを分離し、コンポーネントのテストと保守を容易にする。
- **状態管理**: コンポーネントの状態は、必要最小限に抑える。グローバルな状態はContext APIまたはRedux Toolkitで管理し、ローカルな状態はuseStateフックで管理する。
- **パフォーマンス**: 大量のデータを扱うコンポーネントでは、React.memoやuseCallback、useMemoなどの最適化手法を適用し、不要な再レンダリングを防ぐ。

### 8.3 データ取得とキャッシュ

- **非同期処理**: 外部APIからのデータ取得はすべて非同期で行う。async/await構文を使用して、非同期コードの可読性を高める。
- **エラーハンドリング**: データ取得時のエラーは適切にハンドリングし、ユーザーにフィードバックを提供する。ネットワークエラー、APIからのエラーレスポンス、データ解析エラーなどを考慮する。
- **キャッシュ戦略**: 外部APIへのリクエスト数を減らすため、取得したデータはクライアントサイドでキャッシュする。例えば、IndexedDBやLocal Storage、またはメモリキャッシュ（React Queryなどのライブラリ）を利用する。価格情報や残高データは、30分間隔での自動更新と手動更新に対応する。

### 8.4 Cookieによるデータ永続化

- **データ構造**: Cookieに保存するデータは、JSON形式でシリアライズする。ウォレット情報、ダッシュボードの表示設定、ユーザーIDなど、必要な情報を構造化して保存する。
- **セキュリティ**: Cookieに保存するデータは、機密性の高い情報を含まないようにする。ウォレットアドレスは公開情報だが、ユーザーの識別子としては匿名なものを使用する。必要に応じて、Cookieデータの暗号化を検討する。
- **サイズ制限**: Cookieにはサイズ制限があるため（通常4KB程度）、大量のデータを保存しない。ウォレットのオンチェーンデータ自体はCookieに保存せず、APIから取得する。

### 8.5 UI/UXの実装

- **レスポンシブデザイン**: CSSメディアクエリやTailwind CSSのレスポンシブユーティリティクラスを使用して、異なるデバイスサイズに対応するレイアウトを実装する。
- **ミニマルデザイン**: 白を基調としたシンプルなカラーパレットと、余白を活かしたレイアウトを徹底する。重要な情報には視覚的な強調を施す。
- **カスタマイズ機能**: ダッシュボード項目の表示・非表示設定とドラッグアンドドロップによる位置変更機能を実装する。これらの設定はCookieに保存し、ユーザー体験をパーソナライズする。
- **アクセシビリティ**: セマンティックHTML、ARIA属性、キーボードナビゲーションを考慮した実装を行う。色覚多様性に対応するため、色だけでなくアイコンやテキストで情報を伝える。

### 8.6 パフォーマンス最適化

- **コード分割**: React.lazyとSuspenseを使用して、コンポーネントやルートレベルでのコード分割を行う。これにより、初期読み込み時間を短縮する。
- **画像最適化**: NFT画像などのメディアファイルは、適切なサイズに最適化し、WebPなどのモダンなフォーマットを使用する。遅延読み込み（Lazy Loading）を実装し、ビューポートに入ったときにのみ画像を読み込む。
- **バンドルサイズ**: 不要なライブラリやコードを削除し、JavaScriptバンドルサイズを最小化する。Tree ShakingやPurgeCSSを活用する。
- **APIリクエストの最適化**: 30分間隔での価格情報更新、ウォレットデータ更新により、外部APIへのリクエスト頻度を抑制する。重複するAPIリクエストを避けるためのデバウンスやスロットリングを実装する。


## 9. テスト戦略

本セクションでは、暗号資産ポートフォリオ管理アプリケーションの品質を確保するためのテスト戦略について説明する。静的ウェブページとしての特性と、外部APIへの依存を考慮したテストアプローチを採用する。

### 9.1 テストの種類

- **単体テスト (Unit Testing)**: 個々の関数、コンポーネント、モジュールが期待通りに動作するかを検証する。ReactコンポーネントのテストにはReact Testing LibraryやJestを使用する。
- **結合テスト (Integration Testing)**: 複数のコンポーネントやモジュールが連携して正しく動作するかを検証する。APIモックやシミュレーションを使用して、外部APIへの依存を排除したテストを行う。
- **E2Eテスト (End-to-End Testing)**: ユーザーの視点からアプリケーション全体のフローを検証する。CypressやPlaywrightなどのツールを使用し、ブラウザ上での実際の操作をシミュレートする。Cookieの操作や外部APIのモック化も考慮する。
- **パフォーマンステスト**: アプリケーションの応答時間、読み込み時間、レンダリング速度などを測定し、パフォーマンス要件を満たしているかを確認する。Lighthouseなどのツールを使用する。
- **アクセシビリティテスト**: アプリケーションがアクセシビリティガイドラインに準拠しているかを確認する。Lighthouseやaxe-coreなどのツールを使用する。

### 9.2 テストツール

- **Jest**: JavaScriptのテストフレームワーク。単体テストと結合テストに使用。
- **React Testing Library**: Reactコンポーネントのテストに特化したライブラリ。ユーザーの視点からコンポーネントをテストすることを推奨。
- **Cypress / Playwright**: E2Eテストフレームワーク。ブラウザ上での自動テストに使用。
- **Lighthouse**: Googleが提供するウェブページの品質（パフォーマンス、アクセシビリティ、SEOなど）を評価するツール。

### 9.3 テスト環境

- **開発環境**: ローカルでの開発中に、JestやReact Testing Libraryを用いた単体テスト、結合テストを頻繁に実行する。
- **CI/CD環境**: Gitリポジトリへのプッシュ時に、自動的にテストを実行するCI/CDパイプラインを構築する。これにより、コードの変更が既存の機能に影響を与えないことを確認する。

### 9.4 テストデータ

- **モックデータ**: 外部APIからのレスポンスやブロックチェーンデータをモック化し、テストの再現性と独立性を確保する。
- **テストウォレット**: 実際のブロックチェーンネットワーク上で、テスト用のウォレットアドレスと少量のテスト資産を用意し、E2Eテストや手動テストに使用する。


## 10. デプロイメント

本セクションでは、暗号資産ポートフォリオ管理アプリケーションのデプロイメント戦略について説明する。本アプリケーションは静的ウェブページとして構築されるため、GitHub Pagesを利用したシンプルかつ効率的なデプロイメントプロセスを採用する。

### 10.1 デプロイメント環境

- **GitHub Pages**: GitHubリポジトリから直接静的ウェブサイトをホスティングできるサービス。無料で利用でき、Gitとの連携が容易であるため、本アプリケーションのデプロイ先に最適である。

### 10.2 デプロイメントプロセス

GitHub Pagesへのデプロイは、以下の手順で行う。

1.  **プロジェクトのビルド**: Reactアプリケーションを静的ファイルとしてビルドする。これにより、HTML、CSS、JavaScriptなどの最適化されたファイルが生成される。
    ```bash
    npm run build
    # または
    yarn build
    ```
    このコマンドは通常、`build` ディレクトリ（または`dist`ディレクトリ）にデプロイ可能な静的ファイルを生成する。

2.  **GitHub Pagesへの公開**: ビルドされた静的ファイルをGitHub Pagesに公開する。これにはいくつかの方法がある。

    -   **`gh-pages` ブランチの利用**: `gh-pages` という名前のブランチを作成し、ビルドされたファイルをそのブランチにプッシュする。GitHub Pagesは自動的にこのブランチの内容をウェブサイトとして公開する。
        ```bash
        # ビルドディレクトリに移動
        cd build
        # gh-pagesブランチを初期化
        git init
        git add .
        git commit -m 



    "Deploy to GitHub Pages"
        # リモートリポジトリに追加（もし設定されていなければ）
        # git remote add origin <your-repository-url>
        git push origin master:gh-pages --force
        ```

    -   **`gh-pages` パッケージの利用**: `gh-pages` npmパッケージを使用すると、ビルドディレクトリの内容を簡単に`gh-pages`ブランチにデプロイできる。
        ```bash
        npm install --save-dev gh-pages
        # package.jsonにスクリプトを追加
        # "scripts": {
        #   "predeploy": "npm run build",
        #   "deploy": "gh-pages -d build"
        # }
        npm run deploy
        ```

    -   **GitHub Actionsの利用**: GitHub Actionsを設定し、`main`ブランチへのプッシュ時に自動的にビルドとデプロイを行うCI/CDパイプラインを構築する。これにより、開発者はコードをプッシュするだけで、自動的にウェブサイトが更新されるようになる。

### 10.3 デプロイ後の確認

デプロイが完了すると、GitHub PagesのURL（例: `https://<username>.github.io/<repository-name>/`）でアプリケーションにアクセスできるようになる。デプロイ後には、以下の項目を確認する。

-   アプリケーションが正しくロードされるか。
-   すべての機能が期待通りに動作するか。
-   レスポンシブデザインが各デバイスで正しく適用されるか。
-   外部APIからのデータ取得が正常に行われるか。
-   Cookieによるデータ永続化が機能するか。

### 10.4 カスタムドメイン

必要に応じて、GitHub Pagesにカスタムドメインを設定することができる。リポジトリの設定でカスタムドメインを指定し、DNSプロバイダーでCNAMEレコードを設定することで、よりプロフェッショナルなURLでアプリケーションを公開できる。


## 11. セキュリティ考慮事項

本セクションでは、暗号資産ポートフォリオ管理アプリケーションにおけるセキュリティ考慮事項について説明する。本アプリケーションは静的ウェブページであり、サーバーサイドのバックエンドを持たないため、主にクライアントサイドのセキュリティと外部API連携におけるセキュリティに焦点を当てる。

### 11.1 クライアントサイドセキュリティ

#### 11.1.1 Cookieによるデータ保護

ユーザーのウォレットアドレスやダッシュボード設定はCookieに保存される。これらのデータは機密情報ではないが、改ざんや不正アクセスを防ぐために以下の対策を講じる。

-   **HTTPSの強制**: アプリケーションはHTTPS経由でのみ提供されるようにする。これにより、通信経路での盗聴や改ざんを防ぐ。
-   **HttpOnly属性**: ユーザーIDなど、JavaScriptからアクセスする必要のないCookieには`HttpOnly`属性を設定し、XSS（Cross-Site Scripting）攻撃によるCookieの盗難を防ぐ。
-   **Secure属性**: Cookieには`Secure`属性を設定し、HTTPS接続でのみCookieが送信されるようにする。
-   **SameSite属性**: `SameSite=Lax`または`SameSite=Strict`属性を設定し、CSRF（Cross-Site Request Forgery）攻撃のリスクを軽減する。
-   **データの暗号化**: Cookieに保存するウォレットアドレスや設定データは、クライアントサイドで暗号化して保存することを検討する。これにより、Cookieの内容が直接読み取られることを防ぐ。

#### 11.1.2 入力検証とサニタイズ

ユーザーからの入力（ウォレットアドレス、エイリアスなど）は、クライアントサイドで厳密に検証し、不正なデータや悪意のあるスクリプトの埋め込みを防ぐ。特に、エイリアスやメモなど、表示される可能性のあるテキスト入力に対しては、XSS攻撃を防ぐために適切なサニタイズ処理（HTMLエスケープなど）を行う。

#### 11.1.3 コンテンツセキュリティポリシー (CSP)

CSPを導入し、アプリケーションがロードできるリソース（スクリプト、スタイルシート、画像など）のソースを制限する。これにより、XSS攻撃やデータインジェクション攻撃のリスクを軽減する。特に、外部APIからのデータ表示においては、信頼できるドメインからのリソースのみを許可するように設定する。

### 11.2 外部API連携セキュリティ

#### 11.2.1 APIキーの管理

外部API（ブロックチェーンデータAPI、価格データAPI）を利用する際に必要なAPIキーは、クライアントサイドに直接埋め込むことを避ける。以下の対策を検討する。

-   **公開可能なAPIキーの利用**: 一部のAPIは、公開しても問題ない（レート制限のみで認証不要な）キーを提供している場合がある。これらを活用する。
-   **プロキシサーバーの利用**: APIキーを秘匿する必要がある場合は、Cloudflare WorkersやNetlify Functionsなどのサーバーレス関数を利用して、シンプルなプロキシサーバーを構築する。フロントエンドからはこのプロキシを呼び出し、プロキシがAPIキーを付与して実際の外部APIにリクエストを転送する。

#### 11.2.2 CORS (Cross-Origin Resource Sharing)

外部APIがCORSを適切に設定していることを確認する。フロントエンドからのAPI呼び出しがCORSポリシーによってブロックされないように、APIプロバイダーのドキュメントを確認し、必要に応じてプロキシサーバーを介して呼び出す。

#### 11.2.3 レート制限とDDoS対策

外部APIにはレート制限が設けられているため、これを遵守する。過度なリクエストはAPIプロバイダーからのブロックにつながる可能性がある。クライアントサイドでのレート制限ロジックを実装し、短時間での連続したAPI呼び出しを防ぐ。また、DDoS攻撃の対象とならないよう、APIキーの適切な管理と、不審なリクエストパターンに対する監視を検討する。

### 11.3 一般的なセキュリティプラクティス

-   **依存関係の管理**: 定期的にnpmパッケージの脆弱性スキャン（`npm audit`など）を実行し、既知の脆弱性を持つライブラリを使用していないことを確認する。常に最新のセキュリティパッチが適用されたバージョンを使用する。
-   **最小権限の原則**: 外部APIキーやその他の認証情報には、必要最小限の権限のみを付与する。
-   **エラーメッセージの抑制**: 本番環境では、詳細なエラーメッセージをユーザーに表示しない。攻撃者にシステム内部の情報を与えることを避けるため、一般的なエラーメッセージに留める。


## 12. パフォーマンス最適化

本セクションでは、暗号資産ポートフォリオ管理アプリケーションのパフォーマンス最適化戦略について説明する。静的ウェブページとしての特性を最大限に活かし、高速な読み込みとスムーズなユーザー体験を提供することを目指す。

### 12.1 初期読み込み速度の最適化

-   **コード分割 (Code Splitting)**: Reactアプリケーションのバンドルサイズを小さくするため、ルーティングレベルやコンポーネントレベルでコード分割を行う。ユーザーが最初にアクセスするページに必要なコードのみをロードし、残りのコードは必要に応じて遅延ロードする。
-   **アセットの最適化**: HTML、CSS、JavaScriptファイルをミニファイ（圧縮）し、不要な空白やコメントを削除する。画像（特にNFT画像）は、適切なフォーマット（WebPなど）とサイズに最適化し、圧縮率を上げる。SVGアイコンを使用し、軽量化を図る。
-   **遅延読み込み (Lazy Loading)**: ビューポート外の画像やコンポーネントは、ユーザーがスクロールして表示領域に入ったときに初めてロードするようにする。特にNFTギャラリーなど、大量の画像を表示するセクションで効果的である。
-   **CDNの利用**: GitHub PagesはCDN（Content Delivery Network）を利用してコンテンツを配信するため、ユーザーの地理的な位置に近いサーバーからコンテンツが提供され、読み込み速度が向上する。
-   **ブラウザキャッシュの活用**: 静的ファイルには適切なキャッシュヘッダーを設定し、ブラウザが一度ダウンロードしたファイルを再利用できるようにする。これにより、再訪問時の読み込み速度が大幅に向上する。

### 12.2 データ取得と更新の最適化

-   **API呼び出しの頻度制限**: 価格情報とウォレットデータの更新は、ページオープン時と30分間隔に限定する。これにより、外部APIへの負荷を軽減し、同時にクライアントサイドでの処理負荷も抑える。
-   **クライアントサイドキャッシュ**: 外部APIから取得したデータは、一定期間クライアントサイド（メモリ、IndexedDB、Local Storageなど）にキャッシュする。これにより、同じデータに対する重複したAPI呼び出しを避け、表示速度を向上させる。
-   **バッチ処理**: 複数のウォレットやトークンのデータを取得する際、可能な場合はAPIのバッチエンドポイントを利用し、単一のリクエストで複数の情報を取得する。これにより、ネットワークオーバーヘッドを削減する。
-   **データ変換の最適化**: 取得した生データをUI表示用に変換する処理は、効率的なアルゴリズムを使用し、計算コストを最小限に抑える。Web Workersを利用して、重い計算をメインスレッドからオフロードすることも検討する。

### 12.3 レンダリングパフォーマンスの最適化

-   **仮想化リスト (Virtualization List)**: 大量のリスト（例: トークンリスト、取引履歴）を表示する場合、すべてのアイテムを一度にレンダリングするのではなく、現在ビューポートに表示されているアイテムのみをレンダリングする仮想化リストを導入する。これにより、DOM操作の負荷を軽減し、スクロールパフォーマンスを向上させる。
-   **Reactの最適化機能**: `React.memo`, `useCallback`, `useMemo`などのReactの最適化機能を使用し、不要なコンポーネントの再レンダリングを防ぐ。特に、頻繁に更新されるデータを持つコンポーネントや、計算コストの高いコンポーネントに適用する。
-   **CSS最適化**: Tailwind CSSのPurgeCSS機能を利用し、最終的なCSSバンドルから未使用のCSSを削除する。これにより、CSSファイルのサイズを最小化し、レンダリングブロック時間を短縮する。

### 12.4 ユーザー体験の向上

-   **スケルトンローダー**: データがロードされるまでの間、スケルトンローダーやプレースホルダーを表示し、ユーザーにコンテンツがロード中であることを視覚的に伝える。これにより、待機中のユーザー体験を向上させる。
-   **プログレスインジケーター**: API呼び出しやデータ処理など、時間がかかる操作の際には、プログレスバーやスピナーを表示し、ユーザーに処理の進行状況を知らせる。
-   **エラーメッセージの明確化**: エラー発生時には、ユーザーが理解しやすい具体的なエラーメッセージを表示し、必要に応じて解決策を提示する。


## 13. 今後の拡張計画

本セクションでは、暗号資産ポートフォリオ管理アプリケーションの将来的な拡張計画について説明する。初期リリース後も、ユーザーのニーズやブロックチェーン技術の進化に合わせて、機能追加や改善を継続的に行っていく。

### 13.1 機能拡張

-   **複数チェーン対応の拡充**: 現在のEVM系、Solana系に加えて、Polkadot, Cosmos, Avalanche, Polygonなどの他の主要なブロックチェーンネットワークへの対応を検討する。
-   **DeFiプロトコル連携**: 主要なDeFiプロトコル（例: Uniswap, Aave, Compound, PancakeSwapなど）との連携を強化し、LPトークン、ステーキング、レンディングなどのDeFi資産の表示と管理を可能にする。
-   **取引機能の追加**: アプリケーション内での簡単なトークンスワップや送金機能の追加を検討する。ただし、これは静的ウェブページの範囲を超えるため、ウォレット接続（MetaMask, Phantomなど）と連携したクライアントサイドでの署名・送信機能となる。
-   **アラート機能**: 特定のトークン価格が設定した閾値を超えた場合や、ウォレットに大きな動きがあった場合に、ユーザーに通知する機能（ブラウザ通知など）を追加する。
-   **レポート機能**: 月次・年次のポートフォリオパフォーマンスレポートを生成する機能。CSVエクスポートやPDFレポート出力などを検討する。
-   **税務計算サポート**: 損益計算や税務申告に必要なデータのエクスポート機能を提供する。
-   **ポートフォリオシミュレーション**: 仮想的な取引や価格変動をシミュレートし、ポートフォリオへの影響を予測する機能。

### 13.2 UI/UXの改善

-   **テーマの多様化**: 現在の白ベースのミニマルデザインに加え、ユーザーが選択できるテーマのバリエーションを増やす（例: ダークモードのバリエーション、カラフルなテーマ）。
-   **ウィジェットの追加**: ダッシュボードに表示できるウィジェットの種類を増やす（例: 最新ニュース、ガス料金、主要トークンのミニチャート）。
-   **インタラクティブなチャート**: チャートに詳細なツールチップ、ズーム機能、比較機能などを追加し、より高度な分析を可能にする。
-   **多言語対応**: 日本語以外の言語（英語、中国語など）への対応を検討し、グローバルなユーザーベースに対応する。

### 13.3 パフォーマンスとスケーラビリティの向上

-   **APIプロバイダーの最適化**: より高速で信頼性の高いAPIプロバイダーの探索と統合を継続する。複数のプロバイダーを動的に切り替えるロジックを実装し、可用性を高める。
-   **エッジコンピューティングの活用**: Cloudflare Workersなどのエッジコンピューティングサービスを利用して、APIプロキシやデータキャッシュをユーザーに近い場所で実行し、レイテンシをさらに削減する。
-   **WebAssemblyの検討**: 計算負荷の高い処理（例: 大規模なデータ集計、複雑なグラフ描画）において、WebAssemblyの導入を検討し、パフォーマンスを向上させる。

### 13.4 技術的負債の解消とコード品質の維持

-   **定期的なリファクタリング**: コードベースの健全性を維持するため、定期的にリファクタリングを行い、可読性、保守性を向上させる。
-   **テストカバレッジの向上**: 新機能の追加や既存機能の変更の際には、テストカバレッジを維持または向上させる。
-   **最新技術の導入**: React、TypeScript、関連ライブラリの最新バージョンへの追従を継続し、新しい機能やパフォーマンス改善を取り入れる。


## 14. 参考資料

-   **React公式ドキュメント**: [https://react.dev/](https://react.dev/)
-   **TypeScript公式ドキュメント**: [https://www.typescriptlang.org/](https://www.typescriptlang.org/)
-   **Tailwind CSS公式ドキュメント**: [https://tailwindcss.com/](https://tailwindcss.com/)
-   **React Router公式ドキュメント**: [https://reactrouter.com/](https://reactrouter.com/)
-   **Moralisドキュメント**: [https://docs.moralis.io/](https://docs.moralis.io/)
-   **CoinGecko APIドキュメント**: [https://www.coingecko.com/api/documentation](https://www.coingecko.com/api/documentation)
-   **GitHub Pages**: [https://pages.github.com/](https://pages.github.com/)
-   **MDN Web Docs (Cookie)**: [https://developer.mozilla.org/ja/docs/Web/HTTP/Cookies](https://developer.mozilla.org/ja/docs/Web/HTTP/Cookies)


